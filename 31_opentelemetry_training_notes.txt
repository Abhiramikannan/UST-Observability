1. CNCF:
    The Cloud Native Computing Foundation (CNCF) is part of the Linux Foundation and supports cloud native computing. 
    It helps developers build and run applications using containers and microservices.
    CNCF hosts popular open-source projects like Kubernetes, Prometheus, and Envoy, bringing together developers and companies to collaborate.

WHY DO WE NEED OPENTELEMETRY
-------------------------------------------
2. Observability: 
      Knowing internal parts of system using external outputs.

3. example of observability become crucial:
        diff computers working together to perform tasks as if they were a single system.
        These systems are widely used in applications like cloud computing, where different parts of an application run on different servers to share resources and balance the workload.
        Because of the complexity of distributed systems, it can be challenging to understand what's happening inside each component at any given time. 
        This is where observability becomes crucial.

To understand a distributed system, we model it using three parts:

    Workload: The tasks or transactions the system performs.
    Software structure: Components like load balancers, services, pods, and containers.
    Physical machines: Hardware resources such as CPU, memory, storage, and network.

Workload & Resource Analysis

    Developers focus on workloads (apps and requests).
    Operations teams focus on resources (hardware and performance).
    To fully understand the system, combine both views.
    Use logs, metrics, and traces to capture and analyze system behavior.


4. logs:
    A record of events that happen in a system.
    Log entry: Has a timestamp (when it happened) and a message (what happened).
    No single standard format — logs differ between software (e.g., web server vs. kernel).

5. Metrices:
    Metrics give a high-level view of system performance and health.
    Metrics help us track changes over time using graphs and dashboards.
    Four common types of metrics:
                Counters – Keep increasing (e.g., number of requests).
                Gauges – Go up or down (e.g., CPU or memory usage).
                Histograms – Measure distributions (e.g., request durations).
                Summaries – Show calculated stats like averages or percentiles.

6. Traces:
        Distributed System Architecture 
        
        As systems became larger and more complex, traditional logs were not enough to debug problems.
        In a distributed system, it’s hard to trace how one request moves through many services.
        On a single machine, we can use stack traces to find errors, but this doesn’t work across multiple systems.
        Debugging often required manual work (like matching timestamps) or deep system knowledge.
        To solve this, Google created Dapper, introducing distributed tracing — a method to track a request’s path across all services in a system.

7. 3 pillars of observability?
        metrices
        logs
        traces

8. Telemetry:
        collecting and transmitting data from remote or distributed systems to monitor, track performance of those systems.
        When we collect telemetry data (logs, metrics, and traces), we don’t just collect it — we also need to analyze it to find useful insights
        analyzation - depends on type of telemetry data

9. Vertical Integration?
        The telemetry data (logs,metrices, traces) can be handled differetly.
        logs = search text(find errors contains "timeout")
        metrics= analyse trends over time(e.g., average CPU use in the past 24 hours).
        Traces → You want to visualize a request flow (e.g., see how long each part of a user request took).
        So they need diff data storage, optimization methods, Querry tools.
    one tool that does the full job for a specific kind of telemetry.This is called Vertical Integration.
    Vendors (like Datadog, New Relic, or Grafana) often focus on one type of data at a time.

10.What does “siloed telemetry” mean?
        telemetry = collect data to understand how system behaves.
        siloed = each type of data (logs, metrics, traces) is separate, stored in different tools, and not connected.
    eg: metrices in prometheous, Logs in elasticsearch , traces in jaeger wont talk to eachother automatically.

    This cause an problem:
        when somethg is happening wrong
            u see metric alert - high latency. You search for related metrices maybe cpu, memory. Also move to logging system to find logs.
            logs don’t have trace IDs or context, so you can’t easily tell which logs are linked to the metric spike.
            You can see th whole story of what happened.
Issue:
    lack of corelation.  Hard to link data across systems.
    miss shared metadata (like trace_id or span_id) that would allow you to connect related events.
    This creates fragmented views — you see bits and pieces, but not the full picture of what the system did.
    OpenTelemetry was created to fix this fragmentation.

11. How Opentele helps to fix this fragmentation of telemetric data as compared from traditional approach?
            OpenTelemetry solves this by standardizing how telemetry is collected and by adding shared context (trace IDs, span IDs) so logs, metrics, and
            traces are connected.
            This gives a complete, end-to-end view of system behavior, making debugging faster and easier.


12. Telemtry data suffers from?
         telemetry data often suffers from a lack of consistency.
         OpenTelemetry fixes this by providing a common, standardized instrumentation framework for consistent, high-quality telemetry data.

13. No Built-in Instrumentation in Open Source Software:
            Most apps use open source libraries, but these don’t have built-in telemetry.
            There’s no standard way to collect data from them, and adding vendor tools causes extra work and lock-in.
            Some projects offer hooks so users can connect their own tools, but that’s hard to maintain and often messy.
            OpenTelemetry fixes this by giving all software a common, easy way to add and share telemetry data.


14. what is hook?
        Hooks = built-in connection points in software that let you attach your own code or tools — like OpenTelemetry — without changing the main program itself.

15. Combining Telemetry Generation with Results in Vendor Lock-In :

            When apps use a specific vendor’s telemetry libraries, all the monitoring code becomes tied to that tool.
            If you later want to switch to another observability system, you’d have to remove and rewrite all that code — a big and costly job.
            This makes it hard to move away from one vendor, causing vendor lock-in.
            OpenTelemetry prevents this by offering standard, vendor-neutral instrumentation that works with any observability platform.


16. Struggling Observability Vendors / High Barrier for Entry:

        Software changes fast and is very different everywhere.
        Making instruments for every library and tool is expensive and hard.
        Vendors focus on converting data instead of making better analysis tools.
        This can lower data quality and make troubleshooting harder.
        OpenTelemetry helps by providing a standard, vendor-neutral format, reducing the need for constant custom instrumentation and improving overall data quality.

17. OpenTelemetry (OTel) – In a Nutshell:
        OpenTelemetry is an open-source framework that helps developers collect and send telemetry data — including traces, metrics, and logs — from their applications.
    key goals:
        Unified telemetry – Combines logs, metrics, and traces so data can be correlated easily.
    `   Vendor-neutral – Works with any observability tool or backend.
        Cross-platform – Supports many languages (Java, Python, Go, etc.) and environments.

18. what Opentele is not:
        Not an All-in-One Monitoring or Observability Tool
                dont replace observability platforms like Datadog, New Relic, or Prometheus.It only collects telemteric data.
        Not a Data Storage or Dashboarding Solution
                    export telemetric data to external systems that handle storage and presentation.
        Not a Pre-configured Monitoring Tool
        Not a Performance Optimizer
                it doesn’t automatically optimize application performance


FRAMEWORK:

19.OpenTelemetry Specification 

    OpenTelemetry has three signals: traces, metrics, logs.
    The specification makes telemetry consistent across languages and tools.
    It includes:
        Common terms – shared vocabulary.
        API spec – how to generate, process, and export telemetry.
        SDK spec – guides developers for each programming language.
        Semantic conventions – standard names and meanings for telemetry data.
        OTLP – protocol for sending telemetry between systems.
        Bottom line: The spec ensures all telemetry is compatible, consistent, and easy to use anywhere.

20. Vendor-Agnostic, Language-Specific Instrumentation:
        OpenTelemetry uses language-specific APIs and SDKs to generate telemetry (traces, metrics, logs) in applications.
        API → Simple, lightweight interface used in your code. Does nothing by default.
        SDK → Does the real work: collects, processes, and sends telemetry.

why API is used?
        developers use to add telemetry (logs, metrics, traces) in their code.
        It’s vendor-agnostic → your code doesn’t depend on any specific observability tool.
        Can be a no-op if no SDK is registered, meaning it won’t slow down the app.
        Developers call the API methods in their code, e.g., “record a metric” or “start a trace.”

Why the SDK is used?
        The SDK does the real work of OpenTelemetry: generating, processing, and exporting telemetry data.
        Handles sending data to a backend or observability tool.
        At startup, the app registers an SDK provider. Then, API calls automatically go through the SDK to produce real telemetry.

How API and SDK work together in OpenTelemetry
        You write code using the API to instrument your app.
        You register an SDK provider that implements the API.
        When the app runs, API calls go through the SDK, which collects and sends telemetry.

21. Telemetry Processor (Standalone Component):
        After generating telemetry (logs, metrics, traces), it needs to be collected, processed, and sent to backends like databases or monitoring tools.
        OpenTelemetry Collector is a standalone component that does all of this in one place.

22. Opentelemetry Wire protocol:
        OTLP: OpenTelemetry Protocol, a standard, vendor-neutral way to send telemetry (logs, metrics, traces) between apps, agents, and backends.
        Defines how data is encoded in memory.
        Defines how data is sent over the network.
        Ensures compatibility across tools and observability solutions.

23. What are Semantic Conventions in OpenTelemetry?
        A set of rules for organizing and labeling telemetry data consistently

24.  jaeger tracing:
    OpenTelemetry allows you to export the tracing information to various third-party applications. A popular open source option is a tool called Jaeger Tracing.

25. Automatic (Zero-Code) Instrumentation
        Auto-instrumentation automatically adds monitoring to your app without changing your code.
                    You don’t write code — it just works when you install or enable a tool. eg: You add a plugin, and it automatically tracks all HTTP requests.
                    No code changes needed: It automatically collects telemetry (traces, metrics, logs) without editing your app’s source code.
                    How it works: Uses OpenTelemetry agents or plugins that attach to your app’s runtime.
                    Best for: Quick and easy setup — great for getting started fast.
                    Limitation: You get less control over what’s measured compared to manual instrumentation.
                    Example: Java or Python OpenTelemetry agents that automatically track things like HTTP calls or database queries.

26. Instrumentation libraries:
                tools you add to your code to monitor and understand your app’s behavior.
                eg: In Python (Django) or Java (Spring), you can use OpenTelemetry libraries to track how requests move through your app.
                You add a library (a bit of code) to your app. It might do some things automatically, but you can also add small bits of code to get more detailed data.

27. Manual Instrumentation:
        Adding monitoring code directly inside your program, using tools like the OpenTelemetry API.
        You can decide what needed to be measured and when.
        Deciding when to start and stop collecting data (like starting a trace when a request begins and ending it when it finishes).
        you have full control of whats monitored and when to measure.

28. What is Instrumentation Libraries?
        Add Opentelemetry feature to ur app where there is no build in feature like opentelemetry.
            Some apps use frameworks like Django, Flask ..but these tools don’t always support OpenTelemetry by default.So, OpenTelemetry made special helper libraries to fix that — called instrumentation libraries. You can install these libraries to make your app automatically send tracing and metrics data to OpenTelemetry.


29. How the Instrumentation Library works?
        You have a Django app that handles a web request. Normally, Django just runs the code and sends a response. If you install the OpenTelemetry Django instrumentation library, it: 
            Automatically adds “tracing” code around each web request.
            Measures how long each request takes.
            Sends that data to OpenTelemetry tools (like Jaeger or Grafana).
            You don’t have to rewrite Django — the library does it for you!


27. Challenges of Instrumentation Libraries:
        1. Dependency Management: You are adding extra libraries . This can increase complexity and may require careful updates to keep everything compatible.
        2. Limited Community Support: Some libraries are new or still being tested, so community help or documentation might be limited.

28. Benefits of Instrumentation Libraries:
            1. works with unsupported frameworks:
                    Great for frameworks or libraries that don’t have built-in OpenTelemetry support.
            2. Easy Observability:
                        They let your app collect traces, metrics, and logs without you writing all the code yourself.
            3. Can Work with Auto-Instrumentation:
                    They can be combined with auto-instrumentation tools for even easier setup and broader coverage.

29.  Benefits of Automatic Instrumentation:
            1. No code changes needed
            2. Covers many frameworks: tracks http req, database calls.
            3. Consistent monitoring

30. Challenges of Automatic Instrumentation:
            Less control
            Language limitations
            Limited customization: If u want specific metrics or traces... customization cant do fully automatically.

31. Hands on repo :
        https://github.com/lftraining/LFS148-code

32. Hands on: Exercise 1: Zero-code Instrumentation for Java and Python
        1. Install Opentelemetry Agent: wget https:‌//github.com/open-telemetry/opentelemetry-java-instrumentation/releases/download/v2.8.0/opentelemetry-javaagent.jar

        2. you can simply add it as javaagent parameter:
                java -javaagent:./opentelemetry-javaagent.jar -jar target/todobackend-0.0.1-SNAPSHOT.jar

        3. To setup Opentele agent : Configure the envt variables:
                    telling the agent to only export trace information and to not try to reach out to a collector.
                export OTEL_TRACES_EXPORTER=console
                export OTEL_METRICS_EXPORTER=none
                export OTEL_LOGS_EXPORTER=none

       4.  Run the app using latest setting:
                java -javaagent:./opentelemetry-javaagent.jar -jar target/todobackend-0.0.1-SNAPSHOT.jar

        Congratulations. At this point you have successfully configured your Java app with OpenTelemetry!

        Take another terminal:
                Invoke Application and Observe OpenTelemetry Behavior:
                   5.  curl localhost:8080/todos/
                        output: []%
                            there are no items stored in your application yet.

                    If you execute another curl call in your other shell to add a new item:
                       6.  curl -X POST localhost:8080/todos/NEW

                    We can make our lives easier here and export the information to a visualization tool like Jaeger.
                    7. Now deploy an all-in-one option of the Jaeger application, which comes with a bundled OpenTelemetry collector:
                        docker run -d --name jaeger \
                         -e COLLECTOR_OTLP_ENABLED=true \
                         -p 16686:16686 \
                         -p 14268:14268 \
                         -p 4317:4317 \
                         -p 4318:4318 \
                         jaegertracing/all-in-one

                8. docker ps
                        Include the container called jaeger.

               9.  To ensure the information will be sent to the right endpoint, reconfigure the environment variable from before:
                        export OTEL_TRACES_EXPORTER=otlp

              10. Additionally, configure the location of the Collector by specifying:
                                export OTEL_COLLECTOR_HOST=localhost

                11. Dont need to configure ports:
                        4317 is being used for gRPC and 4318 for HTTP

                12. Run the java app:
                        java -javaagent:./opentelemetry-javaagent.jar -jar target/todobackend-0.0.1-SNAPSHOT.jar
                13. next terminal:
                        curl -X POST localhost:8080/todos/NEW
                14. http:‌//localhost:16686/
                15. curl -X POST localhost:8080/todos/slow

                16. cd $EXERCISES
                    cd automatic-instrumentation/initial/todoui-flask
                    python app.py
                    http:‌//localhost:5000   -> access frontend
                    http:‌//localhost:16686    ->Also access the Jaeger UI
                    pip install opentelemetry-distro opentelemetry-exporter-otlp
                    opentelemetry-bootstrap --action=install
                    pip uninstall opentelemetry-instrumentation-aws-lambda

                    export OTEL_LOGS_EXPORTER="none"
                    export OTEL_METRICS_EXPORTER="none"
                    export OTEL_TRACES_EXPORTER="otlp"
                    export OTEL_EXPORTER_OTLP_ENDPOINT="localhost:4317"
                    export OTEL_SERVICE_NAME=todoui-flask
                    export OTEL_EXPORTER_OTLP_INSECURE=true

                    opentelemetry-instrument python app.py
                    http:‌//localhost:16686/search URL, you can now see that three services have been captured with trace information

        Recap:
                Initial directory: automatic-instrumentation/initial
                Solution directory: automatic-instrumentation/solution
                Java Source code: automatic-instrumentation/initial/todobackend-springboot
                Python Source code: automatic-instrumentation/initial/todoui-flask





33.Exercise 2: Code-Based Instrumentation for Java & Python
cd $EXERCISES
cd automatic-instrumentation/initial/todobackend-springboot
mvn clean package

