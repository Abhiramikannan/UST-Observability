1. In oops what is self that we define inside function?
	self is object that we are passing. If we create a method and call the function by passing the object,that object is passed to self.

2. what objects have?
	attributes
	behaviour

3. what class have?
	methods,properties


4. example:
	car 
	attributes: colour,model,speed
	behaviour: start,stop,accelerate
	methods: functions
	properties: special way to access attributes 

5. __init__method():
	constructor in python
	To initialize the variables
	if we didnt call it also it got executed (Depends upon how many objects we created and used.
	#when we call a function actually we are passing object itself as a parameter automatically if nothing in bracket also.

6. where is heap memory comes?
	#in our computer we will be having heap memory.. which contains all the objects(int,string)
	#object will take some space in your heap memory
	#every space will have an address

7. id() function:
	#id() function = to get address

8. if I create 2 objects will it take same address space?
	No.. every object will have diff address space

9. #how much size it will take and who will allocate the memory to object?
    	 #size of an object depends upon
       	 	#no: of variables
        	#size of each varibale
   	 # who allocates size to object
       		 #constructor...call init method for you internally.

10. compare():
	takes 2 parameters: who is calling, whom to compare.




4 pillars of OOPs:
Inheritance:
    A mechanism where one class (child) acquires properties and behaviors of another class (parent).
    promotes code reuse

    Types of inheritance:
    1. Single
    2. Multilevel
    3. Multiple - 
    4. Heirarchical - one parent multiple children
Inheritance Types:
    1. Single Inheritance:
            Class A inherits Class B 
    2. Multilevel Inheritance: 
             A child class can access all the behaviours from parent class,
                       grand parent class and its ancestors
             eg: Class B inherited from Class A
                 Class C inherited from Class B 
                 So class C will get all features.
    3. Multiple Inheritance:
            Class A and Class B have no relations, They are diff classes.
            C says i want to access features from both A and B.
            C can access both the classes
            Class C(A,B):

Encapsulation:
    Encapsulation means keeping data (attributes) and the methods together in a class,
    while controlling how the data can be accessed from outside the class
     Purpose: Data hiding and controlled access.

     we can make properties private by using double __ 
     To access that use getters method

     To change the private property value use setter method

     Encapuslation :
            have full control of the data ,how to accessed and modified
            data protections: prevents accidental modification
            validataion: validate data before setting it
            Flexibility

polymorphism:
    Ability of an object to take many forms.
    Ability of different classes to respond to the same method name in different ways.
    eg:  A python function can be used on diff objects(string,tuple..) ,function=len()
    x="hello"
    print(len(x)) #gives no of charecters

    x=("apple","orange","banana)
    print(len(x)) #gives no of items in that tuple

    dict1={
        "name":"abhi"
        "age":23
    }
    print(len(dict1)) # print no of key value pairs

Abstraction:
    Hiding implementation details and showing only essential features.


Method overloading:
     Having multiple methods with the same name but different parameters.
    In Python: True overloading (like in Java) is not supported. Instead, we use default arguments or *args to achieve similar behavior.

Method Overriding:
    A child class redefines a method that already exists in the parent class, Diff behaviour.
    Purpose: To provide a specific implementation in the subclass.

 2 types of variables
     instance variables
     static variables

instance variables: As the object changes this value also change.
    #variable created inside init will become instance variable

static variable
    variable created inside init
    define a variable outside init and inside the class called class variable
 
 Namespace?
	its an area where u create  and store object/variable.
	class namespace = class variables
	instance namespace=instance variables

instance method:
     Because we are passing self..so this belongs to a particular object.
    #in instance method u have 2 methods
        # Accessor methods:to fetch the instance variables use accessors
        # Mutator methods: To modify the value of instance variable use mutators.
      

Getters(Accessors) and setters(Mutators):
    Getters get the Value 
    Setters sets the Value

Class method:
Cls:
    If you are working with a class variable you should use cls inside function.
    class methods : Works with class variables
    use @classmethod before the function .. that is called decorator


static method:
    we want to do something without concerning about the variables(instance and class method) and wanna do 
    something extra ..at that time we are using static methods.

innerclass:
     class inside a class can be created
    for example : create a student class with name ,roll no etc.. he have laptop, that details can be created
    in a different class in the same class.
        adv: provide a clean namespace 
            grouping similar things together
        can create the inner class object on outer class



superclass:
         = class A(parent class)
subclass:
     = Class B (Child class) inherited class from a parent class


    

Constructor in inheritance:
        if u create object of subclass, first it will try to find init of subclass if not there,
         then it find init of super class.
         when u create object of subclass it will call init of subclass first , if u have call super then it will
         call init of super class then call init of sub class

Method Resolution Order (MRO)= left to right...(Multiple inheritance)
                order in which Python looks for a method or attribute in a hierarchy of 
                classes when you call it on an object.
                It avoids ambiguity in multiple inheritance and ensures a consistent method lookup order.
super().__init__() =in class C(A,B) ..choose A s init method first


**- Access modifiers:
            public: variables that can access anywhere in the programming (self.name)
            protected: Accessed within the class and subclasses only (_name)
            private: Cannot be accessed directly outside the class (__name)


NUMPY: 
    Numpy is used for working with arrays
    Purpose: Provides fast, efficient operations on large arrays and matrices of numeric data.
    Numpy: Numerical Python
    list serves the purpose of arrays..but they are slow
    numpy aims to provide array object which is 50x faster than lists.
    array object in numpy is called ndarray.provides lot of supporting functions.

why numpy is faster than lists?
    because numpy arrays are stored in a continuous place in memory unlike lists.
    so processes can access and manipulate very efficiently
    this is called point of reference


0 D array:
    Represents a single scalar value (just one number).
    Shape: () (empty tuple).

1 D array: 
    Represents a sequence of values (like a list).
    Shape: (n,) where n is the number of elements.
    Array that has 0 D array as its elements.

2 D array:
    Represents a matrix (rows and columns).
    Shape: (rows, columns).
    Array that have 1 D array as its elements.

3 D array:
    Its a datastructure which stores values in 3 dimension(depth,row,column)
    array which has 2D array as its elements called 3 D arrays.

ndim attribute:
    gives u how many attribute an array have.

Numpy datatypes in python:
    S=string
    i=integer
    f=float
    b=boolean
    complex
    u=unsigned integer
    c=complex float
    m=timedelta
    M=datetime
    O=object
    U=unicode string
    V=void (fixed memory of chunk of other type)

dtype:
    returns datatype of the array

astype():
    creates copy of array

copy and view in numpy:
    copy is the new array
    view is the view of original array

shape of an array in numpy:
    number of elements in each dimension
    numpy array have an attribute called shape which returns tuple with each index having no of corresponding elements.
    shows tupe of(number of rows,no of columns)

Reshapping arrays:
    shape=no of elements in each dimension
    reshape= you can add / delete/ change the number of elements in each dimension.
    eg: reshape from 1 D to 2 D 


*args → collects positional arguments into a tuple.
**kwargs → collects keyword arguments into a dictionary.


PANDAS:
    Pandas is a powerful Python library for data analysis and manipulation
    Pandas stands for “Python Data Analysis Library”.
    It introduces two main data structures:
        Series → 1D labeled array (like a column in Excel)
        DataFrame → 2D labeled table (like an Excel sheet)
    Easy data handling: Load, clean, transform, and analyze data quickly.
    Supports multiple formats: CSV, Excel, SQL, JSON, etc.
    merging and joining datasets.

    why pandas used?
        Data Analysis: Summarizing and exploring datasets.
        Data Cleaning: Removing duplicates, handling missing values.
        Data Transformation: Reshaping, pivoting, merging.
        Reporting: Exporting data to Excel, CSV, or databases.

FILE HANDLING:
    re.sub(pattern,replacement,string)
    The re.sub() function stands for substitute.
    Its job is to find all text that matches a specific pattern and replace it with something else.


API CALLS:
Y grafana token in Api calls?
    if no token -> 401 unauthorized error
    grafana ensures who can access and view the dashboards
    only authorized users can do this
    This token is like a key that allows scripts to access Grafana securely.
    python scripts cant use the username and password, it uses token to access the grafana account.
    program will use a header like this, without header grafana refuses the require
    headers = {
    "Authorization": f"Bearer {TOKEN}",
    "Content-Type": "application/json"
}
    This header says i am an authorized username



FUNCTIONS AND MODULAR CODE:
    Functions are reusable blocks of code that do a specific task
    Each function has a single responsibility, which makes your code cleaner and easier to debug.
    
    Modular code means breaking your program into independent, interchangeable pieces (modules) that can be combined to form the complete program.
    You separated configuration, functions, and the main execution logic.
    This makes your script easier to maintain and read.
    Later, you could even move the functions to a separate Python file (module) and import them in another script:

1. What is AWS SDK for Python (boto3)?
        boto3 is the official Python library to talk to AWS services using code.

Using boto3, you can:
    Create EC2 instances
    Upload files to S3
    Read DynamoDB tables
    Manage IAM users
    Automate AWS tasks (no console clicking)

2. How boto3 authenticate with AWS?
        boto3 needs AWS credentials.

3. Where the credentials are stored?
        ~/.aws/credentials







 






